# effective java 第三版

## 第1章 引言

本书中大多数规则都源于少数几条基本的原则。清晰性和简洁性最为重要：**组件的用户永远也不应该被其行为所迷惑**。

- 组件应该尽可能小，但又不能太小（本书中使用的术语“组件”（Component），是指任何可重用的软件元素，从单个方法，到包含多个包的复杂框架，都可以是一个组件）。
- 代码应该被重用，而不是被拷贝。
- 组件之间的依赖性应该尽可能地降到最小。
- 错误应该尽早被检测出来，最好是在编译时就发现并解决。

本书大部分内容都不是讨论性能的，而是关心如何编写出**清晰、正确、可用、健康、灵活和可维护**的程序来。

Java语言支持四种类型：接口（包括注释）、类（包括enum）、数组和基本类型。前三种类型通常被称为**引用类型（reference type）**，类实例和数组是对象（object），而基本类型的值不是对象。类的成员（member）由它的域（field）、方法（method）、成员类（member class）和成员接口（member interface）组成。方法的签名（signature）由它的名称和所有参数类型组成；签名不包括方法的返回类型。

## 第2章 创建和销毁对象

## 第3章 对于所有对象都通用的方法

尽管 `Object` 是一个具体类，但设计它主要是为了扩展。它所有的非 `final` 方法（equals、hashCode、toString、clone 和 finalize）都有明确的**通用约定（general contract）**，因为它们设计成是要被覆盖（override）的。

### 3.1 覆盖 equals 时请遵守通用约定 - Obey the general contract when overriding equals

如果满足了以下任何一个条件，可以不覆盖 `equals` 方法：

- 类的每个实例本质上是唯一的；
- 类没有必要提供“逻辑相等”（logical equality）的测试功能；
- 超类已经覆盖了 `equals`，超类的行为对于这个类也是合适的。例如，大多数的 `Set` 实现都从 `AbstractSet` 继承了 `equals` 实现；
- 类是私有的，或者是包级私有的，可以确定它的 `equals` 方法永远不会被调用。

如果类具有自己特有的“逻辑相等”（logical equality）概念（不同于对象等同的概念），而且超类还没有覆盖 `equals`，需要覆盖 `equals` 方法。这通常属于“值类”（value class）的情形。值类仅仅是一个表示值的类，例如 `Integer` 或者 `String`。程序员在利用 `equals` 方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。为了满足程序员的要求，不仅必须覆盖 `equals` 方法，而且这样做也使得这个类的实例可以被用作映射表（map）的键（key），或者集合（set）的元素，使映射或者集合表现出预期的行为。

有一种“值类”不需要覆盖 `equals` 方法，即用实例受控确保“每个值至多只存在一个对象”的类。枚举类型就需要这种类。对于这样的类而言，**逻辑相同与对象等同是一回事**，因此 `Object` 的 `equals` 方法等同于逻辑意义上的 `equals` 方法。

在覆盖 `equals` 方法的时候，需要遵守它的通用约定。`equals` 方法实现了**等价关系**（equivalence relation），其属性如下：

- **自反性（reflexive）**：对于任何非 null 的引用值 x， `x.equals(x)` 必须返回 true。
- **对称性（symmetric）**：对于任何非 null 的引用值 x 和 y，当且仅当 `y.equals(x)` 返回 true 时，`x.equals(y)` 必须返回 true。
- **传递性（transitive）**：对于任何非 null 的引用值 x 、y 和 z，如果 `x.equals(y)` 返回 true，并且 `y.equals(z)` 也返回 true，那么 `x.equals(z)` 也必须返回 true。
- **一致性（consistent）**：对于任何非 null 的引用值 x 和 y，只要 `equals` 的比较操作在对象中所用的信息没有被修改，多次调用 `x.equals(y)` 就会一致地返回 true，或者一致地返回 false。
- **非空性（non-nullity）**：对于任何非 null 的引用值 x，`x.equals(null)` 必须返回false。

面向对象语言中关于等价关系的一个基本问题：我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留 `equals` 约定，除非愿意放弃面向对象的抽象所带来的优势。但还是有一种不错的权宜之计：遵从“复合优于继承”的建议。

注意，你可以在一个**抽象（abstract）类**的子类中增加新的组件且不违反 `equals` 的约定。只要不可能直接创建超类的实例，前面所述的种种问题（超类和子类进行等价关系的比较）就都不会发生。

实现高质量 `equals` 方法的诀窍：

- 使用 `==` 操作符检查“参数是否为这个对象的引用”。如果是，则返回 true。这只不过是**一种性能优化**，如果比较操作有可能很昂贵，就值得这么做。
- 使用 `instanceof` 操作符检查“参数是否为正确的类型”。如果不是，则返回 false。一般来说，所谓“正确的类型”是指 `equals` 方法所在的那个类。某些情况下，是指该类所实现的某个接口。如果类实现的接口改进了 `equals` 约定，允许在实现了该接口的类之间进行比较，那么就使用接口。集合接口如 Set、List、Map 和 Map.Entry 具有这样的特性。
- 把参数转换成正确的类型。
- 对于该类中的每个“关键”（significant）域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回 true，否则返回 false。如果第 2 步中的类型是个**接口**，就必须通过接口方法访问参数中的域；如果该类型是个类，也许就能够直接访问参数中的域，这要取决于它们的可访问性。

对于既不是 `float` 也不是 `double` 类型的**基本类型域**，可以使用 `==` 操作符进行比较；对于对象引用域，可以递归地调用 `equals` 方法；对于 `float` 域，可以使用静态 `Float.compare(float, float)` 方法；对于 `double` 域，则使用 `Double.compare(double, double)`。对 `float` 和 `double` 域进行特殊的处理是有必要的，因为存在着 `Float.NaN`、`-0.0f` 以及类似的 `double` 常量。虽然可以使用静态的 `Float.equals` 和 `Double.equals` 对 `float` 和 `double` 域进行比较，但是每次比较都要进行自动装箱，这会导致性能下降。对于数组域，则要把以上这些指导原则应用到每一个元素上。如果数组域中的每个元素都很重要，就可以使用其中一个 `Arrays.equals` 方法。

有些对象引用域包含 `null` 可能是合法的，所以，为了避免可能导致 `NullPointerException` 异常，则使用静态方法 `Objects.equals(Object, Object)` 来检查这类域的等同性。

域的比较顺序可能会影响 `equals` 方法性能。为了获得最佳的性能，应该最先比较最有可能不一致的域，或者开销最低的域，最理想的情况是两个条件同时满足的域。不应该比较那些不属于对象逻辑状态的域，例如用于同步操作的 `Lock` 域。也不需要比较 **衍生域（derived field）**，因为这些域可以由“关键域”（significant field）计算获得，但是这样做有可能提高 `equals` 方法的性能。如果衍生域代表了整个对象的**综合描述**，比较这个域可以节省在比较失败时去比较实际数据所需要的开销。例如，假设有一个 `Polygon` 类，并缓存了该面积。如果两个多边形有着不同的面积，就没有必要去比较它们的边和顶点。

下面是最后的一些告诫：

- 覆盖 `equals` 时总要覆盖 `hashCode`。
- 不要企图让 `equals` 方法过于智能。把任何一种别名形式考虑到等价的范围内，往往不会是个好注意。例如，`File` 类不应该试图把指向同一个文件的符号链接（symbolic link）当作相等的对象来看待。所幸 `File` 类没有这么做。
- 不要将 `equals` 声明中的 `Object` 对象替换为其他的类型。可能会造成没有覆盖（override） `Object.equals`，相反，可能重载（overload）了 `Object.equals`。

使用 Google 开源的 AutoValue 框架代替手工编写和测试 `equals` 及 `hashCode`，它会自动替你生成这些方法，通过类中的单个注解就能触发。

### 3.2 覆盖 equals 时总要覆盖 hashCode - Always override hasCode when you override equals

在每个覆盖 `equals` 方法的类中，都必须覆盖 `hashCode` 方法。如果不这样做的话，就会违反 `hashCode` 的通用约定，从而导致该类**无法结合所有基于散列的集合**一起正常运作，这类集合包括 `HashMap` 和 `HashSet`。下面是约定的内容，摘自 `Object` 规范：

- 在应用程序的执行期间，只要对象的 `equals` 方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，`hashCode` 方法都必须始终返回同一个值。在一个应用程序与另一个程序的执行过程中，执行 `hashCode` 方法所返回的值可以不一致。
- 如果两个对象根据 `equals(Object)` 方法比较是相等的，那么调用这两个对象中的 `hashCode` 方法都必须产出同样的整数结果。
- 如果这两个对象根据 `equals(Object)` 方法比较是不相等的，那么调用这两个对象中的 `hashCode` 方法，则不一定要求 `hashCode` 方法必须产生不同的结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。 

理想情况下，散列函数应该把集合中不相等的实例均匀地分布到所有可能的 int 值上。要想完全达到这种理想的情形是非常困难的。幸运的是，相对接近这种理想情形则并不太困难。下面给出一种简单的解决办法：

- 1.声明一个 int 变量并命名为 `result`，将它初始化为对象中第一个关键域的散列码 `c`，如步骤 2.a 中计算所示（关键域是指影响 equals 比较的域）。
- 2.对象中剩下的每一个关键域 `f` 都完成如下步骤：
    - a. 为该域计算 int 类型的散列码 `c`：
        - I. 如果该域是基本类型，则计算 `Type.hashCode(f)`，这里的 `Type` 是装箱基本类型的类，与 `f` 的类型相对应。
        - II. 如果该域是一个对象引用，并且该类的 `equals` 方法通过递归地调用 `equals` 的方式来比较这个域，则同样为这个域递归地调用 `hashCode`。如果需要更复杂的比较，则为这个域计算一个“范式”（canonical representation），然后针对这个范式调用 `hashCode`。如果这个域的值为 `null`，则返回 `0`（或者其他某个常数，但通常是0）。
        - III. 如果该域是一个数组，则要把每一个元素当作单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤 2.b 中的做法把这些散列值组合起来。如果数组域中没有重要的元素，可以使用一个常量，但最后不要用 `0`。如果数组域中的所有元素都很重要，可以使用 `Arrays.hashCode` 方法。
    - b. 按照下面的公式，把步骤 2.a 中计算得到的散列码 `c` 合并到 `result` 中：`result = 31 * result + c`。
- 3.返回 `result`。

在散列的计算过程中，可以把**衍生域（derived field）** 排除在外。必须排除 `equals` 比较计算中没有用到的任何域，否则很有可能违反 `hashCode` 约定的第二条。

步骤 2.b 中的乘法部分使得散列值依赖于**域的顺序**，如果一个类包含多个相似的域，这样的乘法运算就会产生一个更好的散列函数。例如，如果 `String` 散列函数省略了这个乘法部分，那么只是字母顺序不同的所有字符串将会有相同的散列码。之所以选择 **31**，是因为它是一个**奇素数**。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与 2 相乘等价于移位运算。使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果。**31** 有个很好的特性，即用移位和减法来代替乘法，可以得到更好的性能：`31 * i == (i << 5) - i`。现代的虚拟机可以自动完成这种优化。

如果一个类是不可变的，并且计算散列码的开销比较大，就应该考虑把散列码**缓存在对象内部**，而不是每次请求的时候都重新计算散列码。如果你觉得这种类型的大多数对象会被用作散列键（hash kyes），就应该在创建实例的时候计算散列码。否则，可以选择“延迟初始化”（lazily initialize）散列码，即一直到 `hashCode` 被第一次调用的时候才初始化。

不要试图从散列码计算中排除掉一个对象的关键域来提高性能。虽然这样得到的散列函数运行起来可能更快，但是它的效果不见得会好，可能会导致散列表慢到根本无法使用。

### 3.3 始终要覆盖 toString - Always override toString

虽然 `Object` 提供了 `toString`方法的一个实现，但它返回的字符串通常并不是类的用户所期望看到的。它包含类的名称、以及一个 “@” 符号，接着是散列码的无符号十六进制表示法，例如 `PhoneNumber@163b91`。`toString` 的通用约定指出，被返回的字符串应该是一个“简洁的但信息丰富，并且易于阅读的表达形式”。`toString` 约定进一步指出，“建议所有的子类都覆盖这个方法”。

遵守 `toString` 约定并不像遵守 `equals` 和 `hashCode` 的约定那么重要，但是，**提供好的 toString 实现可以使类用起来更加舒适，使用了这个类的系统也更易于调试**。

在实际应用中，`toString` 方法应该返回对象中包含的所有值得关注的信息。如果对象太大，或者对象中包含的状态信息难以用字符串来表达，这样做就有点不切实际。在这种情况下，`toString` 应该返回一个**摘要信息**。理想情况下，字符串应该是自描述的（self-explanatory）。

在实现 `toString` 的时候，必须要做出一个很重用的决定：是否在文档中指定返回值的格式。对于值类（value class），比如电话号码类、矩阵类，建议这么做。指定格式的好处是，它可以被用作一种标准的、明确的、适合人阅读的对象表示法。这种表示法可以用于输入和输出，以及用在永久适合人类阅读的数据对象中，例如 CSV 文档。如果你指定了格式，通常最好再提供一个**相匹配的静态工厂或者构造器**，以便程序员可以很容易地在对象及其字符串表示法之间来回转换。Java平台类库中的许多值类都采用了这种做法，包括 `BigInteger`、`BigDecimal` 和绝大多数的基本类型包装类（boxed primitive class）。

指定 `toString` 返回值的格式也有不足之处：如果这个类已经被广泛使用，一旦指定格式，就必须始终如一地坚持这种格式。程序员将会编写出相应的代码来解析这种字符串表示法、产生字符串表示法，以及把字符串表示法嵌入持久的数据中。如果将来的发行版中改变了这种表示法，就会破坏它们的代码和数据，他们当然会抱怨。如果不指定格式，就可以保留灵活性，便于在将来的发行版本中增加信息，或者改进格式。

无论是否决定指定格式，都应该在文档中明确地表明你的意图。如果要指定格式，则应该严格地这样去做。

无论是否指定格式，**都为 toString 返回值中包含的所有信息提供一种可以通过编程访问之的途径（如get方法）**。如果不这么做，就会迫使需要这些信息的程序员不得不自己去解析这些字符串。除了降低了程序的性能，使得程序员去做这些不必要的工作之外，这个解析过程也很容易出错，导致系统不稳定，如果格式发生变化，还会导致系统崩溃。如果没有提供这些访问方法，即使你已经指明了字符串的格式是会变化的，这个字符串格式也成了事实上的 API。

在静态工具类中编写 `toString` 方法是没有意义的。也不要在大多数枚举中编写 `toString` 方法，因为 Java 已经为你提供了非常完美的方法。但是，在所有其子类共享通用字符串表示法的抽象类中，一定要编写一个 `toString` 方法。例如，大多数集合实现中的 `toString` 方法都是继承自抽象的集合类。

### 3.4 谨慎地覆盖 clone - Override clone judiciously

`Cloneable` 接口的目的是作为对象的一个 mixin 接口（mixin interface），表明这样的对象允许克隆（clone）。遗憾的是，它并没有成功地达到这个目的。它的主要缺陷在于缺少一个 `clone` 方法，而 `Object` 的 `clone` 方法是**受保护**的。如果不借助于反射（reflection），就不能仅仅因为一个对象实现了 `Cloneable`，就调用 `clone` 方法。即使是反射调用也可能会失败，因为不能保证该对象一定具有**可访问**的 `clone` 方法。

既然 `Cloneable` 接口并没有包含任何方法，那么它到底有什么作用呢？它决定了 `Object` 中受保护的 `clone` 方法实现的行为：如果一个类实现了 `Cloneable`，`Obejct` 的 `clone` 方法就返回该对象的**逐域拷贝**（a field-by-field copy of the object），否则就会抛出 `CloneNotSupportException` 异常。这是接口的一种极端非典型的用法，也不值得仿效。通常情况下，实现接口是为了表明类可以为它的客户做些什么。然而，对于 `Cloneable` 接口，它改变了超类中受保护的方法的行为。

虽然规范中没有明确指出，事实上，实现 `Cloneable` 接口的类是为了提供一个功能适当的公有的 `clone` 方法。为了达到这个目的，**类及其所有超类**都必须遵守一个相对复杂的、不可实施的，并且基本上没有文档说明的协议。由此得到一种语言之外的（extralinguistic）机制：**它无须调用构造函数就可以创建对象**。

`clone` 方法的通用约定是非常弱的，下面是来自 `Object` 规范中的约定内容：

创建和返回该对象的一个拷贝。这个“拷贝”的精确含义取决于该对象的类。一般的含义是，对于任何对象 `x`，表达式：

`x.clone() != x`

将会返回结果 true，并且表达式

`x.clone().getClass() == x.getClass()`

将会返回结果 true，但这些都不是绝对的要求。虽然通常情况下，表达式

`x.clone().equals(x)`

将会返回结果 true，但是，这也不是一个绝对的要求。

按照约定，这个方法返回的对象应该通过调用 `super.clone` 获得。如果类及其超类（Object 除外）遵守这一约定，那么

`x.clone().getClass() == x.getClass`

按照约定，返回的对象应该不依赖于被克隆的对象。为了成功地实现这种**独立性**，可能需要在 `super.clone` 返回对象之前，修改对象的一个或更多个域。

假设你希望在一个类中实现 `Cloneable` 接口，并且它的**超类都提供了行为良好的 clone 方法**。首先，调用 `super.clone` 方法。由此得到的对象将是原始对象功能完整的克隆（clone）。在这个类中声明的域将等同于被克隆对象中相应的域。如果每个域包含一个基本类型的值，或者包含一个指向不可变对象的引用，那么被返回的对象则可能正是你所需要的对象，在这种情况下不需要做进一步处理。但是要注意，**不可变的类永远都不应该提供 clone 方法**，因为它只会激发不必要的克隆（克隆对象和被克隆对象中的域完全相同）。

如果对象中包含的域引用了**可变的对象**，使用上述这种简单的 `clone` 实现可能会导致灾难性的后果（修改原始的实例会破坏被克隆对象中的约束条件，反之亦然）。实际上，`clone` 方法就是另一个构造器；必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件（invariant）。例如 `Stack` 类中包含数组类型的 `elements` 域，最容易的做法是，在 `elements` 数组中递归地调用 `clone`：

```java
@Override
public Stack clone() {
    try {
        Stack result = (Stack) super.clone();
        result.elements = elements.clone();
        return result;
    } catch(CloneNotSupportException e) {
        throw new AssertionError();
    }
}
```

注意，我们不一定要将 `elements.clone()` 的结果转换成 `Object[]`。在数组上调用 `clone` 返回的数组，其**编译时的类型** 与被克隆数组的类型相同。这是复制数组的最佳习惯做法。事实上，**数组是 clone 方法唯一吸引人的用法**。

还有注意如果 `elements` 域是 `final` 的，上述方案就不能正常工作，因为 `clone` 方法是被禁止给 `final` 域赋新值的。这是个根本的问题：就像序列化一样，**Cloneable 架构与引用可变对象的 final 域的正常用法是不相兼容的**，除非在原始对象和克隆对象之间可以安全地共享此可变对象。为了使类成为可克隆的，可能有必要从某些域中去掉 `final` 修饰符。

递归地调用 `clone` 有时还不够。例如，假设你正在为一个散列表编写 `clone` 方法，它的内部数据包含一个散列桶数组，每个散列桶都指向“键 - 值”对链表的第一项。出于性能方面的考虑，该类实现了它自己的轻量级单项链表，而没有使用 Java 内部的 `java.util.LinkedList`。我们除了要递归地克隆这个散列桶数组，还必须单独地拷贝组成每个桶的链表。

克隆复杂对象的最后一个办法是，先调用 `super.clone` 方法，然后把结果对象中的所有域设置成它们的初始状态（initial state），然后调用高层（higher-level）的方法来重新产生对象的状态。这种做法往往会产生一个简单、合理且相当优美的 `clone` 方法，但是它运行起来通常没有“直接操作对象及其克隆对象的内部状态的 clone 方法”快。虽然这种方法干脆利落，但它与整个 `Cloneable` 架构是对立的，因为它完全抛弃了 `Cloneable` 架构基础的逐域对象复制的机制。

像构造器一样，`clone` 方法也不应该在构造的过程中，调用可以覆盖的方法。如果 `clone` 调用了一个在子类中被覆盖的方法，那么在该方法所在的子类有机会修正它在克隆对象中的状态之前，该方法就会先被执行，这样很有可能会导致克隆对象和原始对象之间不一致。

`Object` 的 `clone` 方法被声明为可抛出 `CloneNotSupportException` 异常，但是，覆盖版本的 `clone` 方法可以忽略这个声明。**公有的 clone 方法应该省略 throws 声明**，因为不会抛出受检异常的方法使用起来更加轻松。

为继承设计类有两种选择，但是无论选择其中的哪一种方法，这个类都不应该实现 `Cloneable` 接口。

还有一点值得注意。如果你编写一个实现了 `Cloneable` 接口的线程安全的类，要记住它的 `clone` 方法必须得到严格的同步（synchronized clone()），就像任何其他方法一样。

简而言之，所有实现了 `Cloneable` 接口的类都应该覆盖 `clone` 方法，并且是公有的方法，它的返回类型为类本身。该方法应该先调用 `super.clone` 方法，然后修正任何需要修正的域。一般情况下，这意味着要**拷贝任何包含内部“深层结构”的可变对象**，并且指向新对象的引用代替原来指向这些对象的引用。虽然，这些内部拷贝操作往往可以通过递归地调用 `clone` 来完成，但这通常不是最佳方法。如果该类只包含基本类型的域，或者执行不可变对象的引用，那么多半的情况是没有域需要修正的。这条规则也有例外。例如，代表序列号或者唯一 ID 值的域，不管这些域是基本类型还是不可变的，它们也都需要做修正。

对象拷贝的更好的办法是提供一个拷贝构造器（copy constructor）或拷贝工厂（copy factory）。例如：

```java
// Copy constructor
public Yum(Yum yum) { ... };

// Copy factory
public static Yum newInstance(Yum yum) { ... };
```

拷贝构造器的做法，及其静态工厂方法的变形，都比 `Cloneable/clone` 方法具有更多的优势：它们不依赖于某一种很有风险的、语言之外的对象创建机制；它们不要求遵守尚未定制好文档的规范；它们不会与 `final` 域的正常使用发生冲突；它们不会抛出不必要的受检异常；它们不需要进行类型转换。

甚至，拷贝构造器或者拷贝工厂可以带一个参数，参数类型是该类所实现的接口。例如，按照惯例所有通用集合实现都提供了一个拷贝构造器，其参数类型为 `Collection` 或者 `Map` 接口。基于接口的拷贝构造器和拷贝工厂（更准确的叫法应该是转换构造器（conversion constructor）和转换工厂（conversion factory）），允许客户选择拷贝的实现类型，而不是强迫客户接受原始的实现类型。

总之，复制功能最好由构造器或者工厂提供。这条规则最绝对的例外是数组，最好利用 `clone` 方法复制数组。

## 第4章 类和接口

类和接口是Java编程语言的核心，它们也是Java语言的基本抽象单元。Java语言提供了许多强大的基本元素，供程序员用来设计类和接口。本章阐述的一些指导原则，可以帮助你更好地利用这些元素，设计出**更加有用、健壮和灵活**的类和接口。

### 4.1 使类和成员的可访问性最小化 - Minimize the accessbility of classes and members

区分一个组件设计得好不好，唯一重要的因素在于，它对于外部的组件而言，**是否隐藏了其内部数据和其他实现细节**。设计良好的组件**会隐藏所有的实现细节，把API与实现清晰地隔离开来**。然后，组件之间只通过API进行通信，一个模块不需要知道其他模块的内部工作情况。这个概念称为**信息隐藏（information hiding）或封装（encapsulation）**，是软件设计的基本原则之一。

信息隐藏可以有效地解除组成系统的各组件之间的耦合关系，即**解耦（decouple）**，使得这些组件可以**独立地开发、测试、优化、使用、理解和修改**。

- 因为这些组件可以并发开发，所以**加快了系统开发的速度**。
- 同时**减轻了维护的负担**，程序员可以更快地理解这些组件，并且在调试它们的时候不影响其他的组件。
- 虽然信息隐藏本身无论是对内还是对外都不会带来更好的性能，但是可以**有效地调节性能**：一旦完成一个系统，并通过剖析确定了哪些组件影响了系统的性能，那么组件就可以被进一步优化，而不会影响到其他组件的正确性。
- 信息隐藏**提高了软件的重用性**，因为组件之间并不紧密相连，除了开发这些模块所使用的环境之外，它们在其他的环境中往往也很有用。
- 最后，信息隐藏也**降低了构建大型系统的风险**，因为即使整个系统不可用，这些独立的组件仍有可能是可用的。

Java提供了许多机制（facility）来协助信息隐藏。**访问控制（access control）机制**决定了类、接口和成员的**可访问性（accessibility）**。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的**访问修饰符（private, protected和public）** 共同决定的。正确地使用这些修饰符对于实现信息隐藏是非常关键的。

规则很简单：**尽可能地使每个类或者成员不被外界访问**。换句话说，应该使用与你正在编写的软件的对应功能相一致的、尽可能最小的访问级别。

对于**顶层的（非嵌套的）类和接口**，只有两种可能的访问级别：**包级私有的（package-private）和公有的（public）**，**默认**是包级私有的。

- 如果类或者接口能够被做成包级私有的，它就应该被做成包级私有的。
- 通过把类或者接口做成包级私有的，它实际上就成了**这个包的实现的一部分，而不是该包导出API的一部分**，在以后的发行版中，可以对它进行修改、替换或者删除，而无需担心会影响到现有的客户端程序。如果把它做成公有的，你就有责任永远支持它，以保持它们的**兼容性**。
- 如果一个包级私有的顶级类（或者接口）**只是**在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的**私有嵌套类**。这样就可以将它的可以访问范围从包中的所有类缩小到使用它的那个类。
- 然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的可访问性重要得多：因为公有类是包的API的一部分，而包级私有的顶层类则已经是这个包的实现的一部分。

对于**成员（域、方法、嵌套类和嵌套接口）** 有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：

- 私有的（private）：只有在声明该成员的顶层类内部才可以访问这个成员。
- 包级私有的（package-private）：声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被成为“缺省”（default）访问级别，如果**没有为成员指定访问修饰符**，就采用这个级别（当然，接口成员除外，它们默认的访问级别是公有的）。
- 受包含的（protected）：声明该成员的类的子类可以访问这个成员（但有一些限制），并且声明该成员的包内部的任何类也可以访问这个成员。
- 公有的：在任何地方都可以访问该成员。

导出类的受保护成员也代表了该类对于某个实现细节的公开承诺，应该尽量少用受保护的成员。

有一条规则限制了降低**方法**的可访问性的能力。**如果方法覆盖了超类中的一个方法，子类中的方法的访问级别就不允许低于超类中的方法级别**。这样可以确保任何可以使用超类的实例的地方也都可以使用子类的实例（里氏替换原则）。这条规则有一个特例：如果一个类实现了一个接口，那么接口中所有的方法在这个类中也都必须被声明为公有的。

**公有类的实例域决不能是公有的**。如果实例域是**非final**的，或者是**一个指向可变对象的final引用**，那么一旦使这个域成为公有的，就等于放弃了对存储在这个域中值进行限制的能力；这就意味着，你也放弃了强制这个域不可变的能力。同时，当这个域被修改的时候，你也失去了对它采用任何行动的能力。因此，**包含公有可变域的类通常并不是线程安全的**。即使域是final的，并且引用不可变的对象，但当把这个域变成公有的时候，也就放弃了“切换到一种新的内部数据表示法”的灵活性。

这条建议也同样适用于静态域，只是有一种情况例外。假设常量构成了类提供的整个抽象中的一部分，可以通过**公有的静态final域**来暴露这些常量。按惯例，这种域的名称由大写字母组成，单词之间用下划线隔开。很重要的一点，这些域要么包含**基本类型的值**，要么包含**指向不可变对象的引用**。如果final域包含可变对象的引用，它便具有非final域的所有缺点。**虽然引用本身不能被修改，但是它引用的对象却可以被修改**，这会导致灾难性的后果。

注意，**长度非零的数组总是可变的**，所以让类具有公有的静态final数组域，或者返回这种域的访问方法，这是错误的。可以通过以下两种方式处理

```java
// 方法一，增加一个公有的不可变对象
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

// 方法二，返回私有数组的一个拷贝
public static final Thind[] values() {
    return PRIVATE_VALUES.clone();
}
```

总而言之，应该始终尽可能（合理）地降低程序元素的可访问性。在仔细设计了一个最小的公有API之后，应该防止把任何散乱的类、接口或者成员变成API的一部分。除了公有静态final域的特殊情形之外（此时它们充当常量），公有类都不应该包含公有域，并且要确保公有静态final域所引用的对象都是不可变的。

### 4.2 要在公有类而非公有域中使用访问方法 - In public classes, use accessor methods, not public fields

**如果类可以在它所在的包之外进行访问，就提供访问方法**，以保留将来改变该类的内部表示法的灵活性。如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为公有类的客户端代码已经遍布各处了。

然而，**如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据源并没有本质的错误**-假设这些数据源确实描述了该类所提供的抽象。在私有嵌套类的情况下，改变的作用范围被进一步限制在外围类中。

### 4.3 使可变性最小化 - Minimize mutability

**不可变类**是指**其实例不能被修改的类**。每个实例中包含的**所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期（lifetime）内固定不变**。

Java平台类库中包含许多不可变的类，其中有**String、基本类型的包装类、BigInteger和BigDecimal**。

存在不可变的类有许多理由：不可变的类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。

为了使类成为不可变，要遵循下面五条规则：

- 不要提供任何会修改对象状态的方法（也称为设置方法）；
- 保证类不会被扩展。防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为。为了防止子类化，一般做法是声明这个类成为final的；
- 声明所有的域都是final的。通过系统的强制方式可以清楚地表明你的意图；
- 声明所有的域都为私有的。这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象；
- 确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要使用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法（accesser）中返回对象的引用。在**构造器、访问方法和readObject方法中请使用保护性拷贝（defensive copy）技术**。

不可变对象的优点：

- 不可变对象比较简单。不可变对象只有一种状态，即被创建时的状态。
- 不可变对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这些对象时，它们不会遭到破坏。不可变对象可以被自由地共享。不可变类应该充分利用这种优势，鼓励客户端尽可能地重用现有的实例。
    - 对于频繁用到的值，为它们提供**公有的静态final常量**。
    - 不可变的类可以提供一些静态工厂，它们把频繁被请求的实例缓存起来，从而当现有实例可以符合请求的时候，就不必创建新的实例。所有基本类型的包装类和BigInteger都有这样的静态工厂。使用这样的静态工厂也使得客户端之间可以共享现有的实例，而不用创建新的实例，从而降低内存占用和垃圾回收的成本。
    - “不可变对象可以被自由地共享”导致的结果是，永远也不需要进行保护性拷贝。
- 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。
- 不可变对象为其他对象提供了大量的组件，无论是可变的对象还是不可变的对象。如果知道一个复杂对象内部的组件对象不会改变，要维护它的不变约束是比较容易的。这条原则的一种特例在于，不可变对象构成了大量的映射键（map key）和集合元素（set element）；一旦不可变对象进入到映射（map）或者集合（set）中，尽快这破坏了映射或者集合的不变性约束，但是也不用担心它们的值会发生变化。
- 不可变对象无偿地提供了失败的原子性。它们的状态永远不变，因此不存在临时不一致的可能性。

不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。创建这些对象的代价可能很高，特别是大型的对象。

为了确保不可变性，类绝对不允许自身被子类化。除了“使类称为final的”这种方法之外，还有另外一种更加**灵活**的办法可以做到这一点。让类的所有构造器都变成私有的或者包级私有的，并提供公有的静态工厂（static final）来代替公有的构造器。这种方法虽然并不常用，但它通常是最好的替代方法。它最灵活，因为它允许使用多个包级私有的实现类。对于处于包外部的客户端而言，不可变的类实际上是final的，因为不可能对来自另一个包的类、缺少公有的或受保护的构造器的类进行扩展。除了允许多个实现类的灵活性之外，这种方法还使得有可能通过改善静态工厂的对象缓存能力，在后续的发行版本中改进该类的性能。

```java
// Immutable class with static factories instead of constructors
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    // Remainder unchanged
}
```

为了提高性能，规则可以有所放松。事实上应该是这样的：没有一个方法能够对对象的状态产生**外部可见（externally visible）** 的改变。然而，许多不可变的类拥有一个或者多个非final的域，它们在第一次被请求执行这些计算的时候，把一些开销昂贵的计算结果缓存在这些域中（外部不可见）。如果将来再次请求同样的计算，就直接返回这些缓存的值，从而节约了重新计算所需要的开销。这种技巧可以很好地工作，因为对象是不可变的，它的不可变性保证了这些计算如果被再次执行，就会产生同样的结果。

有关序列化功能的一条告诫：如果你选择让自己的不可变类实现了`Serializable`接口，并且它包含一个或者多个指向可变对象的域，就必须提供一个显示的`readObject`或者`readResolve`方法，或者使用`ObjectOutputStream.writeUnshared`和`ObjectInputStream.readUnshared`方法，即便默认的序列化形式是可以接受的，也是如此。

- 坚决不要为每个get方法编写一个相应的set方法。
- 除非有很好的理由要让类称为可变的类，否则它就应该是不可变的。
- 如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的。
- 构造器应该创建完全初始化的对象，并建立起所有的约束关系。同样地，不应该提供“重新初始化”方法（它使得对象可以被重用，就好像这个对象是由另一个不同的初始化状态构造出来的一样）。与所增加的复杂性相比，“重新初始化”方法通常并没有带来太多的性能优势。

### 4.4 复合优先于继承 - Favor composition over inheritance

继承（inheritance）是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。使用不当会导致软件变得很脆弱。在包的内部使用继承是非常安全的，在那里子类和超类的实现都处在同一个程序员的控制之下。对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的。然而，对普通的具体类（concrete class）进行跨越包边界的继承，则是非常危险的。本条目中讨论的问题并不适用于**接口继承（当一个类实现一个接口的时候，或者当一个接口扩展另一个接口的时候）**。

与调用方法不同的是，**继承打破了封装性**。换句话说，**子类依赖于其超类中特定功能的实现细节**。超类的实现有可能会随着发行版本的不同而有所变化，如果真的发生了变化，子类可能会遭到破坏，即使它的代码完全没有改变。因而，子类必须要跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。

导致子类脆弱的一个相关原因是，它们的超类在后续的发行版本中可以获得新的方法。

不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。这种设计被称为“复合”（composition），因为现有的类变成了新类的一个组件。新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。这被称为**转发（forwarding）**，新类中的方法被称为**转发方法（forwarding method）**。这样得到的类将会非常稳固，它不依赖于现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。

有时复合和转发的结合也被宽松地称为“委托”。从技术的角度而言，这不是委托，除非包装对象把自身传递给被包装的对象。

包装类（wrapper class）不适合于回调框架（callback framework）；在回调框架中，对象把自身的引用传递给其他的对象，用于后续的调用（“回调”）。因为被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时避开了外面的包装对象。这被称为**SFLF问题**。

只有当子类真正是超类的子类型（subtype）时，才适合继承。换句话说，对于两个类 A 和 B ，只有当两者之间确实存在 “is-a” 关系的时候，类 B 才应该扩展类 A 。

简而言之，继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处于不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性（fragility）。为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。

### 4.5 要么设计继承并提供文档说明，要么禁止继承 - Design and document for inheritance or else prohibit it

首先，该类的文档必须精确地描述覆盖每个方法所带来的影响。换句话说，**该类必须有文档说明它可覆盖（overridable）的方法的自用性（self-use）**。对于每个**公有的**或**受保护的**方法或者构造器，它的文档必须指明该方法或者构造器调用了哪些**可覆盖的方法**，是以什么顺序调用的，每个调用的过程又是如何影响后续处理过程的（所谓的可覆盖的方法，是指非final的、公有的或受保护的）。

为了继承而进行的设计不仅仅涉及自用模式的文档设计。为了使程序员能够编写出更加有效的子类，而无须承受不必要的痛苦，**类必须以精心挑选的受保护的（proctected）方法的形式，提供适当的钩子（hook），以便进入其内部工作中**。这种形式也可以是罕见的实例，或者受保护的域。

对于为了继承而设计的类，唯一的测试方法就是编写子类。

为了允许继承，类还必须遵守其他一些约束：

- **构造器决不能调用可被覆盖的方法**，无论是直接调用还是间接调用。超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器运行之前先被调用。如果该覆盖版本的方法依赖于子类构造器所执行的任何初始化工作，该方法将不会如预期般执行。通过构造器调用私有的方法、final方法和静态方法是安全的，这些都不是可以被覆盖的方法。
- 如果你决定在一个为了继承而设计的类中实现`Cloneable`接口，无论是`clone`和`readObject`方法，都不可以调用可覆盖的方法，不管是直接还是间接的形式。对于`readObject`方法，覆盖的方法将在子类的状态被反序列化（deserialized）之前被运行；而对于`clone`方法，覆盖的方法则是在子类的`clone`方法有机会修正被克隆对象的状态之前先被运行。无论哪种情形，都不可避免地将导致程序失败。
- 如果你决定在一个为了继承而设计的类中实现`Serializable`接口，并且该类有一个`readResolve`或者`writeReplace`方法，就必须使`readResolve`或者`writeReplace`方法成为受保护的方法，而不是私有的方法。如果这些方法是私有的，那么子类将会不声不响地忽略掉这两个方法。

对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种方法可以禁止子类化：

- 把这个类声明为final的；
- 把所有的构造器都变成私有的，或者包级私有的，并增加一些公有的静态工厂来替代构造器。

如果类实现了某个能够反映其本质的接口，比如`Set`、`List`或者`Map`，可以使用**包装类（wrapper）** 模式，让继承机制实现更多的功能。

### 4.6 接口优于抽象类 - Prefer interfaces to abstract classes

Java提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从 Java 8 为继承引入了**缺省方法（default method）**，这两种机制都允许为某些**实例方法**提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须成为抽象类的一个子类。因为 Java 只允许**单继承**，所以用抽象类作为类型定义受到了限制。任何定义了**所有必要的方法并遵守通用约定的类**，都允许实现一个接口，无论这个类是处在类层次结构中的什么位置。

现有的类可以很容易被更新，以实现新的接口。如果这些方法尚不存在，你所需要的就只是增加必要的方法，然后在类的声明中增加一个 `implements` 子句。一般来说，无法更新现有的类来扩展新的抽象类。

接口是定义 `mixin` （混合类型）的理想选择。不严格地讲，`mixin` 类型是指：类除了实现它的“基本类型”之外，还可以实现这个 `mixin` 类型，以表明它提供了某些**可供选择**的行为。例如，`Comparable` 是一个 `mixin` 接口，它允许类表明它的实例可以与其他的可相互比较的对象进行排序。这样的接口之所以被称为 `mixin`，是因为它允许**任选**的功能可被混合到类型的**主要功能**中。抽象类不能被用于定义 `mixin`，同样是因为它不能被更新到现有的类中：类不可能有一个以上的父类，类层次结构中也没有适当的地方来插入 `mixin`。

接口允许构造**非层次结构**的类型框架。类型层次对于组织某些事物是非常合适的，但是其他事物并不能被整齐地组织成一个严格的层次结构。

通过**包装类（wrapper class）模式**，接口使得安全地增强类的功能成为可能。

当一个接口方法根据其他接口方法有了明显的实现时，可以考虑以**缺省方法**的形式为程序员提供帮助。

通过缺省方法可以提供的实现协助是有限的。虽然许多接口都定义了 `Object` 方法的行为，如 `equals` 和 `hashCode`，但是**不允许给它们提供缺省方法**。而且接口不允许包含实例域或者非公有的静态成员（私有的静态方法除外）。最后一点，无法给不受控制的接口添加缺省方法。

但是，通过对接口提供一个抽象的**骨架实现（skeletal implemention）**类，可以把接口和抽象类的优点结合起来。接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现**除基本类型接口方法之外， 剩下的非基本类型接口方法**。扩展骨架实现占了实现接口之外的大部分的工作。这就是**模板方法（Template Method）模式**。

按照惯例，骨架实现类被称为 Abstract*Interface*，这里的 Interface 是指所实现的接口名字。例如， Collections Framework 为每个重要的集合接口都提供了一个骨架实现，包括 AbstractCollection、AbstractSet、AbstractList 和 AbstractMap。

骨架实现类的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加“抽象类被用作类型定义时”所特有的严格限制。

总而言之，接口通常是定义允许多个实现的类型的最佳途径。如果你导出了一个重要的接口，就应该坚决考虑同时提供骨架实现类。而且，还应该尽可能地通过缺省方法在接口中提供骨架实现，以便接口的所有实现类都能使用。也就是说，对于接口的限制，通常也限制了骨架实现会采用的抽象类的形式。

### 4.7 为后代设计接口 - Design interfaces for posterity

在 Java 8 中，增加了**缺省方法（default method）** 构造，目的就是允许给现有的接口添加方法。

缺省方法的声明中包括一个**缺省实现（default implementation）**，这是给实现了该接口但没有实现默认方法的所有类使用的。虽然 Java 中增加了缺省方法之后，可以给现有接口添加方法了，但是并不能确保这些方法在之前存在的实现中都能良好运行。因为这些默认的方法是被“注入”到现有实现中，它们的实现者并不知道，也没有许可。在 Java 8 之前，编写这些实现时，是默认它们的接口永远不需要任何新方法的。

有了缺省方法，接口的现有实现就不会出现编译时没有报错或警告，运行时却失败的情况。

建议尽量避免利用缺省方法在**现有接口**上添加新的方法。然而，在**创建接口**的时候，用缺省方法提供标准的方法实现是非常方便的，它简化了实现接口的任务。

还有主要的是，缺省方法**不支持从接口中删除方法，也不支持修改现有方法的签名**。

### 4.8 接口只用于定义类型 - Use interfaces only to define types

当类实现接口时，接口就充当可以引用这个类的实例的**类型（type）**。因此，类实现了接口，就表明客户端可以对这个类的实例实施某些动作。为了任何其他目的而定义接口是不恰当的。

有一种接口称为**常量接口（constant interface）**，它不满足上面的条件。这种接口不包含任何方法，它只包含**静态的final域**，每个域都导出一个常量。使用这些常量的类实现这个接口，以避免用类名来修饰常量名。

**常量接口模式是对接口的不良使用**。类在内部使用某些常量，这纯粹是实现细节。实现常量接口会导致把这样的实现细节泄露到该类的导出API中。

如果要导出常量，可以有几种合理的选择方案：

- 如果这些常量与某个现有的类或者接口紧密相关，就应该把这些常量添加到这个类或者接口中；
- 如果这些常量最好被看作枚举类型的成员，就应用使用**枚举类型（enum type）** 来导出这些常量。否则，就应该使用**不可实例化的工具类（utility class）** 来导出这些常量。

总而言之，接口应该只被用来定义类型，它们不应该被用来导出常量。

### 4.9 类层次优于标签类 - Prefer class hierarchies to tagged classes

有时可能会遇到带有两种甚至更多风格的实例的类，并包含表示实例风格的**标签（tag）域**。这种**标签类（tagged class）** 有许多缺点。

- 它们中充斥着样版代码，包括枚举声明、标签域以及条件语句；
- 由于多个实现乱七八糟地挤在单个类中，破坏了可读性；
- 由于实例承担着属于其他风格的不相关的域，因此内存占用也增加了；
- 域不能做成 final 的，除非构造器初始化了不相关的域，产生了更多的样版代码；
- 无法给标签类添加新的风格，除非可以修改它的源文件。

一句话，标签类过于冗长、容易出错，并且效率低下。

幸运的是，Java提供了其他更好的方法来定义能表示多种风格对象的单个数据类型：子类型化（subtyping）。**标签类正是对类层次的一种简单效仿**。

将标签类转变成类层次步骤：
- 首先要为标签类中的每个方法都定义一个包含抽象方法的抽象类，标签类的行为依赖于标签值；
- 如果还有其他的方法行为不依赖于标签的值，就把这样的方法放在这个抽象类中；
- 同样地，如果所有的方法都用到了某些数据域，就应该把它们放在这个抽象类中；
- 接下来，为每种标签类都定义这个抽象类的具体子类。

类层次纠正了前面提到过的标签类的所有缺点。同时，它们可以用来反映类型之间本质上的层次关系，有助于增强灵活性，并有助于更好地进行编译时类型检查。

### 4.10 静态成员优于非静态成员 - Favor static member classes over nonstatic

**嵌套类（nested class）** 是指定义在另一个类的内部的类。嵌套类存在的目的应该只是为了它的**外围类（enclosing class）** 提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该是**顶层类（top-level class）**。

嵌套类有四种：**静态成员类（static member class）**、**非静态成员类（nonstatic member class）**、**匿名类（anonymous class）** 和 **局部类（local class）**。除了静态成员类，其他三种都成为**内部类（inner class）**。

**静态成员类**是普通的类，只是碰巧被声明在另一个类的内部而已，它可以**访问外围类的所有成员，包括那些声明为私有的成员**。静态成员类是外围类的一个静态成员，与其他的静态成员一样，也遵守同样的可访问性规则。如果它被声明为私有的，它就只能在外围类的内部才可以被访问，等等。

**静态成员类**的一种常见用法是**作为公有的辅助类**，只有与它的外部类一起使用才有意义。

**私有静态成员类**的一种常见用法是代表外围类所代表的对象的组件。

与**静态成员类**类相比，**非静态成员类**的每个实例都隐含地与外围类的一个**外围实例（enclosing instance）** 相关联。在**非静态成员类**的实例方法内部，可以调用外围实例的方法，或是使用修饰过的**this(qulified this)** 构造获得外围实例的引用。如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是**静态成员类**：在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。

当非静态成员类的实例被创建的时候，**它和外围实例之间的关联关系也随之被建立起来**；而且，这种关联关系以后不能被修改。通常情况下，当外围类的某个实例方法的内部调用非静态成员类的构造器时，这种关联关系被自动建立起来。使用表达式**enclosingInstance.new MemberClass(args)** 类手动建立这种关联关系也是有可能的，但是很少使用。**这种关联关系需要消耗非静态成员类实例的空间，并且增加构造的时间开销**。

非静态成员类的一种常见用法是**定义一个 Adapter**，它允许外部类的实例被看作是另一个不相关的类的实例。

非静态成员类的每个实例都将包含一个额外的指向外围对象的引用，保持这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收时仍然得以保留。由此造成的内存泄露可能是灾难性的。但是常常难以发现，因为这样引用是不可见的。

匿名类是没有名字的，它不是外围类的一个成员。它并不与其他的成员一起被声明，而是在使用的同时被声明和实例化。匿名类可以出现在代码中任何允许存在表达式的地方。当且仅当匿名类出现在非静态的环境中时，它采用外围实例。但是即使它们出现在静态的环境中，也不可能拥有任何静态成员，而是拥有**常数常量（constant variable）** ，常数常量是 final 基本类型，或者被初始化成常量表达式的字符串域。

局部类是四种嵌套类中使用最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。

## 第5章 泛型

## 第6章 枚举和注解

## 第7章 Lambda和Stream

## 第8章 方法

## 第9章 通用编程

## 第10章 异常

## 第11章 并发

## 第12章 序列化
