# effective java 第三版

## 第1章 引言

本书中大多数规则都源于少数几条基本的原则。清晰性和简洁性最为重要：**组件的用户永远也不应该被其行为所迷惑**。

- 组件应该尽可能小，但又不能太小（本书中使用的术语“组件”（Component），是指任何可重用的软件元素，从单个方法，到包含多个包的复杂框架，都可以是一个组件）。
- 代码应该被重用，而不是被拷贝。
- 组件之间的依赖性应该尽可能地降到最小。
- 错误应该尽早被检测出来，最好是在编译时就发现并解决。

本书大部分内容都不是讨论性能的，而是关心如何编写出**清晰、正确、可用、健康、灵活和可维护**的程序来。

Java语言支持四种类型：接口（包括注释）、类（包括enum）、数组和基本类型。前三种类型通常被称为**引用类型（reference type）**，类实例和数组是对象（object），而基本类型的值不是对象。类的成员（member）由它的域（field）、方法（method）、成员类（member class）和成员接口（member interface）组成。方法的签名（signature）由它的名称和所有参数类型组成；签名不包括方法的返回类型。

## 第2章 创建和销毁对象

## 第3章 对于所有对象都通用的方法

## 第4章 类和接口

类和接口是Java编程语言的核心，它们也是Java语言的基本抽象单元。Java语言提供了许多强大的基本元素，供程序员用来设计类和接口。本章阐述的一些指导原则，可以帮助你更好地利用这些元素，设计出**更加有用、健壮和灵活**的类和接口。

### 4.1 使类和成员的可访问性最小化 - Minimize the accessbility of classes and members

区分一个组件设计得好不好，唯一重要的因素在于，它对于外部的组件而言，**是否隐藏了其内部数据和其他实现细节**。设计良好的组件**会隐藏所有的实现细节，把API与实现清晰地隔离开来**。然后，组件之间只通过API进行通信，一个模块不需要知道其他模块的内部工作情况。这个概念称为**信息隐藏（information hiding）或封装（encapsulation）**，是软件设计的基本原则之一。

信息隐藏可以有效地解除组成系统的各组件之间的耦合关系，即**解耦（decouple）**，使得这些组件可以**独立地开发、测试、优化、使用、理解和修改**。

- 因为这些组件可以并发开发，所以**加快了系统开发的速度**。
- 同时**减轻了维护的负担**，程序员可以更快地理解这些组件，并且在调试它们的时候不影响其他的组件。
- 虽然信息隐藏本身无论是对内还是对外都不会带来更好的性能，但是可以**有效地调节性能**：一旦完成一个系统，并通过剖析确定了哪些组件影响了系统的性能，那么组件就可以被进一步优化，而不会影响到其他组件的正确性。
- 信息隐藏**提高了软件的重用性**，因为组件之间并不紧密相连，除了开发这些模块所使用的环境之外，它们在其他的环境中往往也很有用。
- 最后，信息隐藏也**降低了构建大型系统的风险**，因为即使整个系统不可用，这些独立的组件仍有可能是可用的。

Java提供了许多机制（facility）来协助信息隐藏。**访问控制（access control）机制**决定了类、接口和成员的**可访问性（accessibility）**。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的**访问修饰符（private, protected和public）** 共同决定的。正确地使用这些修饰符对于实现信息隐藏是非常关键的。

规则很简单：**尽可能地使每个类或者成员不被外界访问**。换句话说，应该使用与你正在编写的软件的对应功能相一致的、尽可能最小的访问级别。

对于**顶层的（非嵌套的）类和接口**，只有两种可能的访问级别：**包级私有的（package-private）和公有的（public）**，**默认**是包级私有的。

- 如果类或者接口能够被做成包级私有的，它就应该被做成包级私有的。
- 通过把类或者接口做成包级私有的，它实际上就成了**这个包的实现的一部分，而不是该包导出API的一部分**，在以后的发行版中，可以对它进行修改、替换或者删除，而无需担心会影响到现有的客户端程序。如果把它做成公有的，你就有责任永远支持它，以保持它们的**兼容性**。
- 如果一个包级私有的顶级类（或者接口）**只是**在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的**私有嵌套类**。这样就可以将它的可以访问范围从包中的所有类缩小到使用它的那个类。
- 然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的可访问性重要得多：因为公有类是包的API的一部分，而包级私有的顶层类则已经是这个包的实现的一部分。

对于**成员（域、方法、嵌套类和嵌套接口）** 有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：

- 私有的（private）：只有在声明该成员的顶层类内部才可以访问这个成员。
- 包级私有的（package-private）：声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被成为“缺省”（default）访问级别，如果**没有为成员指定访问修饰符**，就采用这个级别（当然，接口成员除外，它们默认的访问级别是公有的）。
- 受包含的（protected）：声明该成员的类的子类可以访问这个成员（但有一些限制），并且声明该成员的包内部的任何类也可以访问这个成员。
- 公有的：在任何地方都可以访问该成员。

导出类的受保护成员也代表了该类对于某个实现细节的公开承诺，应该尽量少用受保护的成员。

有一条规则限制了降低**方法**的可访问性的能力。**如果方法覆盖了超类中的一个方法，子类中的方法的访问级别就不允许低于超类中的方法级别**。这样可以确保任何可以使用超类的实例的地方也都可以使用子类的实例（里氏替换原则）。这条规则有一个特例：如果一个类实现了一个接口，那么接口中所有的方法在这个类中也都必须被声明为公有的。

**公有类的实例域决不能是公有的**。如果实例域是**非final**的，或者是**一个指向可变对象的final引用**，那么一旦使这个域成为公有的，就等于放弃了对存储在这个域中值进行限制的能力；这就意味着，你也放弃了强制这个域不可变的能力。同时，当这个域被修改的时候，你也失去了对它采用任何行动的能力。因此，**包含公有可变域的类通常并不是线程安全的**。即使域是final的，并且引用不可变的对象，但当把这个域变成公有的时候，也就放弃了“切换到一种新的内部数据表示法”的灵活性。

这条建议也同样适用于静态域，只是有一种情况例外。假设常量构成了类提供的整个抽象中的一部分，可以通过**公有的静态final域**来暴露这些常量。按惯例，这种域的名称由大写字母组成，单词之间用下划线隔开。很重要的一点，这些域要么包含**基本类型的值**，要么包含**指向不可变对象的引用**。如果final域包含可变对象的引用，它便具有非final域的所有缺点。**虽然引用本身不能被修改，但是它引用的对象却可以被修改**，这会导致灾难性的后果。

注意，**长度非零的数组总是可变的**，所以让类具有公有的静态final数组域，或者返回这种域的访问方法，这是错误的。可以通过以下两种方式处理

```java
// 方法一，增加一个公有的不可变对象
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

// 方法二，返回私有数组的一个拷贝
public static final Thind[] values() {
    return PRIVATE_VALUES.clone();
}
```

总而言之，应该始终尽可能（合理）地降低程序元素的可访问性。在仔细设计了一个最小的公有API之后，应该防止把任何散乱的类、接口或者成员变成API的一部分。除了公有静态final域的特殊情形之外（此时它们充当常量），公有类都不应该包含公有域，并且要确保公有静态final域所引用的对象都是不可变的。

### 4.2 要在公有类而非公有域中使用访问方法 - In public classes, use accessor methods, not public fields

**如果类可以在它所在的包之外进行访问，就提供访问方法**，以保留将来改变该类的内部表示法的灵活性。如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为公有类的客户端代码已经遍布各处了。

然而，**如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据源并没有本质的错误**-假设这些数据源确实描述了该类所提供的抽象。在私有嵌套类的情况下，改变的作用范围被进一步限制在外围类中。

### 4.3 使可变性最小化 - Minimize mutability

**不可变类**是指**其实例不能被修改的类**。每个实例中包含的**所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期（lifetime）内固定不变**。

Java平台类库中包含许多不可变的类，其中有**String、基本类型的包装类、BigInteger和BigDecimal**。

存在不可变的类有许多理由：不可变的类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。

为了使类成为不可变，要遵循下面五条规则：

- 不要提供任何会修改对象状态的方法（也称为设置方法）；
- 保证类不会被扩展。防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为。为了防止子类化，一般做法是声明这个类成为final的；
- 声明所有的域都是final的。通过系统的强制方式可以清楚地表明你的意图；
- 声明所有的域都为私有的。这样可以防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象；
- 确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要使用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法（accesser）中返回对象的引用。在**构造器、访问方法和readObject方法中请使用保护性拷贝（defensive copy）技术**。

不可变对象的优点：

- 不可变对象比较简单。不可变对象只有一种状态，即被创建时的状态。
- 不可变对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这些对象时，它们不会遭到破坏。不可变对象可以被自由地共享。不可变类应该充分利用这种优势，鼓励客户端尽可能地重用现有的实例。
    - 对于频繁用到的值，为它们提供**公有的静态final常量**。
    - 不可变的类可以提供一些静态工厂，它们把频繁被请求的实例缓存起来，从而当现有实例可以符合请求的时候，就不必创建新的实例。所有基本类型的包装类和BigInteger都有这样的静态工厂。使用这样的静态工厂也使得客户端之间可以共享现有的实例，而不用创建新的实例，从而降低内存占用和垃圾回收的成本。
    - “不可变对象可以被自由地共享”导致的结果是，永远也不需要进行保护性拷贝。
- 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。
- 不可变对象为其他对象提供了大量的组件，无论是可变的对象还是不可变的对象。如果知道一个复杂对象内部的组件对象不会改变，要维护它的不变约束是比较容易的。这条原则的一种特例在于，不可变对象构成了大量的映射键（map key）和集合元素（set element）；一旦不可变对象进入到映射（map）或者集合（set）中，尽快这破坏了映射或者集合的不变性约束，但是也不用担心它们的值会发生变化。
- 不可变对象无偿地提供了失败的原子性。它们的状态永远不变，因此不存在临时不一致的可能性。

不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。创建这些对象的代价可能很高，特别是大型的对象。

为了确保不可变性，类绝对不允许自身被子类化。除了“使类称为final的”这种方法之外，还有另外一种更加**灵活**的办法可以做到这一点。让类的所有构造器都变成私有的或者包级私有的，并提供公有的静态工厂（static final）来代替公有的构造器。这种方法虽然并不常用，但它通常是最好的替代方法。它最灵活，因为它允许使用多个包级私有的实现类。对于处于包外部的客户端而言，不可变的类实际上是final的，因为不可能对来自另一个包的类、缺少公有的或受保护的构造器的类进行扩展。除了允许多个实现类的灵活性之外，这种方法还使得有可能通过改善静态工厂的对象缓存能力，在后续的发行版本中改进该类的性能。

```java
// Immutable class with static factories instead of constructors
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }

    // Remainder unchanged
}
```

为了提高性能，规则可以有所放松。事实上应该是这样的：没有一个方法能够对对象的状态产生**外部可见（externally visible）** 的改变。然而，许多不可变的类拥有一个或者多个非final的域，它们在第一次被请求执行这些计算的时候，把一些开销昂贵的计算结果缓存在这些域中（外部不可见）。如果将来再次请求同样的计算，就直接返回这些缓存的值，从而节约了重新计算所需要的开销。这种技巧可以很好地工作，因为对象是不可变的，它的不可变性保证了这些计算如果被再次执行，就会产生同样的结果。

有关序列化功能的一条告诫：如果你选择让自己的不可变类实现了`Serializable`接口，并且它包含一个或者多个指向可变对象的域，就必须提供一个显示的`readObject`或者`readResolve`方法，或者使用`ObjectOutputStream.writeUnshared`和`ObjectInputStream.readUnshared`方法，即便默认的序列化形式是可以接受的，也是如此。

- 坚决不要为每个get方法编写一个相应的set方法。
- 除非有很好的理由要让类称为可变的类，否则它就应该是不可变的。
- 如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性。除非有令人信服的理由要使域变成非final的，否则要使每个域都是private final的。
- 构造器应该创建完全初始化的对象，并建立起所有的约束关系。同样地，不应该提供“重新初始化”方法（它使得对象可以被重用，就好像这个对象是由另一个不同的初始化状态构造出来的一样）。与所增加的复杂性相比，“重新初始化”方法通常并没有带来太多的性能优势。

### 4.4 复合优先于继承 - Favor composition over inheritance

继承（inheritance）是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。使用不当会导致软件变得很脆弱。在包的内部使用继承是非常安全的，在那里子类和超类的实现都处在同一个程序员的控制之下。对于专门为了继承而设计并且具有很好的文档说明的类来说，使用继承也是非常安全的。然而，对普通的具体类（concrete class）进行跨越包边界的继承，则是非常危险的。本条目中讨论的问题并不适用于**接口继承（当一个类实现一个接口的时候，或者当一个接口扩展另一个接口的时候）**。

与调用方法不同的是，**继承打破了封装性**。换句话说，**子类依赖于其超类中特定功能的实现细节**。超类的实现有可能会随着发行版本的不同而有所变化，如果真的发生了变化，子类可能会遭到破坏，即使它的代码完全没有改变。因而，子类必须要跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明。

导致子类脆弱的一个相关原因是，它们的超类在后续的发行版本中可以获得新的方法。

不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。这种设计被称为“复合”（composition），因为现有的类变成了新类的一个组件。新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果。这被称为**转发（forwarding）**，新类中的方法被称为**转发方法（forwarding method）**。这样得到的类将会非常稳固，它不依赖于现有类的实现细节。即使现有的类添加了新的方法，也不会影响新的类。

有时复合和转发的结合也被宽松地称为“委托”。从技术的角度而言，这不是委托，除非包装对象把自身传递给被包装的对象。

包装类（wrapper class）不适合于回调框架（callback framework）；在回调框架中，对象把自身的引用传递给其他的对象，用于后续的调用（“回调”）。因为被包装起来的对象并不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时避开了外面的包装对象。这被称为**SFLF问题**。

只有当子类真正是超类的子类型（subtype）时，才适合继承。换句话说，对于两个类 A 和 B ，只有当两者之间确实存在 “is-a” 关系的时候，类 B 才应该扩展类 A 。

简而言之，继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则。只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处于不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性（fragility）。为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。

### 4.5 要么设计继承并提供文档说明，要么禁止继承 - Design and document for inheritance or else prohibit it

首先，该类的文档必须精确地描述覆盖每个方法所带来的影响。换句话说，**该类必须有文档说明它可覆盖（overridable）的方法的自用性（self-use）**。对于每个**公有的**或**受保护的**方法或者构造器，它的文档必须指明该方法或者构造器调用了哪些**可覆盖的方法**，是以什么顺序调用的，每个调用的过程又是如何影响后续处理过程的（所谓的可覆盖的方法，是指非final的、公有的或受保护的）。

为了继承而进行的设计不仅仅涉及自用模式的文档设计。为了使程序员能够编写出更加有效的子类，而无须承受不必要的痛苦，**类必须以精心挑选的受保护的（proctected）方法的形式，提供适当的钩子（hook），以便进入其内部工作中**。这种形式也可以是罕见的实例，或者受保护的域。

对于为了继承而设计的类，唯一的测试方法就是编写子类。

为了允许继承，类还必须遵守其他一些约束：

- **构造器决不能调用可被覆盖的方法**，无论是直接调用还是间接调用。超类的构造器在子类的构造器之前运行，所以，子类中覆盖版本的方法将会在子类的构造器运行之前先被调用。如果该覆盖版本的方法依赖于子类构造器所执行的任何初始化工作，该方法将不会如预期般执行。通过构造器调用私有的方法、final方法和静态方法是安全的，这些都不是可以被覆盖的方法。
- 如果你决定在一个为了继承而设计的类中实现`Cloneable`接口，无论是`clone`和`readObject`方法，都不可以调用可覆盖的方法，不管是直接还是间接的形式。对于`readObject`方法，覆盖的方法将在子类的状态被反序列化（deserialized）之前被运行；而对于`clone`方法，覆盖的方法则是在子类的`clone`方法有机会修正被克隆对象的状态之前先被运行。无论哪种情形，都不可避免地将导致程序失败。
- 如果你决定在一个为了继承而设计的类中实现`Serializable`接口，并且该类有一个`readResolve`或者`writeReplace`方法，就必须使`readResolve`或者`writeReplace`方法成为受保护的方法，而不是私有的方法。如果这些方法是私有的，那么子类将会不声不响地忽略掉这两个方法。

对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。有两种方法可以禁止子类化：

- 把这个类声明为final的；
- 把所有的构造器都变成私有的，或者包级私有的，并增加一些公有的静态工厂来替代构造器。

如果类实现了某个能够反映其本质的接口，比如`Set`、`List`或者`Map`，可以使用**包装类（wrapper）** 模式，让继承机制实现更多的功能。

### 4.6 接口优于抽象类 - Prefer interfaces to abstract classes

Java提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。自从 Java 8 为继承引入了**缺省方法（default method）**，这两种机制都允许为某些**实例方法**提供实现。主要区别在于，为了实现由抽象类定义的类型，类必须成为抽象类的一个子类。因为 Java 只允许**单继承**，所以用抽象类作为类型定义受到了限制。任何定义了**所有必要的方法并遵守通用约定的类**，都允许实现一个接口，无论这个类是处在类层次结构中的什么位置。

现有的类可以很容易被更新，以实现新的接口。如果这些方法尚不存在，你所需要的就只是增加必要的方法，然后在类的声明中增加一个 `implements` 子句。一般来说，无法更新现有的类来扩展新的抽象类。

接口是定义 `mixin` （混合类型）的理想选择。不严格地讲，`mixin` 类型是指：类除了实现它的“基本类型”之外，还可以实现这个 `mixin` 类型，以表明它提供了某些**可供选择**的行为。例如，`Comparable` 是一个 `mixin` 接口，它允许类表明它的实例可以与其他的可相互比较的对象进行排序。这样的接口之所以被称为 `mixin`，是因为它允许**任选**的功能可被混合到类型的**主要功能**中。抽象类不能被用于定义 `mixin`，同样是因为它不能被更新到现有的类中：类不可能有一个以上的父类，类层次结构中也没有适当的地方来插入 `mixin`。

接口允许构造**非层次结构**的类型框架。类型层次对于组织某些事物是非常合适的，但是其他事物并不能被整齐地组织成一个严格的层次结构。

通过**包装类（wrapper class）模式**，接口使得安全地增强类的功能成为可能。

当一个接口方法根据其他接口方法有了明显的实现时，可以考虑以**缺省方法**的形式为程序员提供帮助。

通过缺省方法可以提供的实现协助是有限的。虽然许多接口都定义了 `Object` 方法的行为，如 `equals` 和 `hashCode`，但是**不允许给它们提供缺省方法**。而且接口不允许包含实例域或者非公有的静态成员（私有的静态方法除外）。最后一点，无法给不受控制的接口添加缺省方法。

但是，通过对接口提供一个抽象的**骨架实现（skeletal implemention）**类，可以把接口和抽象类的优点结合起来。接口负责定义类型，或许还提供一些缺省方法，而骨架实现类则负责实现**除基本类型接口方法之外， 剩下的非基本类型接口方法**。扩展骨架实现占了实现接口之外的大部分的工作。这就是**模板方法（Template Method）模式**。

按照惯例，骨架实现类被称为 Abstract*Interface*，这里的 Interface 是指所实现的接口名字。例如， Collections Framework 为每个重要的集合接口都提供了一个骨架实现，包括 AbstractCollection、AbstractSet、AbstractList 和 AbstractMap。

骨架实现类的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加“抽象类被用作类型定义时”所特有的严格限制。

总而言之，接口通常是定义允许多个实现的类型的最佳途径。如果你导出了一个重要的接口，就应该坚决考虑同时提供骨架实现类。而且，还应该尽可能地通过缺省方法在接口中提供骨架实现，以便接口的所有实现类都能使用。也就是说，对于接口的限制，通常也限制了骨架实现会采用的抽象类的形式。

### 4.7 为后代设计接口 - Design interfaces for posterity

在 Java 8 中，增加了**缺省方法（default method）** 构造，目的就是允许给现有的接口添加方法。

缺省方法的声明中包括一个**缺省实现（default implementation）**，这是给实现了该接口但没有实现默认方法的所有类使用的。虽然 Java 中增加了缺省方法之后，可以给现有接口添加方法了，但是并不能确保这些方法在之前存在的实现中都能良好运行。因为这些默认的方法是被“注入”到现有实现中，它们的实现者并不知道，也没有许可。在 Java 8 之前，编写这些实现时，是默认它们的接口永远不需要任何新方法的。

有了缺省方法，接口的现有实现就不会出现编译时没有报错或警告，运行时却失败的情况。

建议尽量避免利用缺省方法在**现有接口**上添加新的方法。然而，在**创建接口**的时候，用缺省方法提供标准的方法实现是非常方便的，它简化了实现接口的任务。

还有主要的是，缺省方法**不支持从接口中删除方法，也不支持修改现有方法的签名**。

### 4.8 接口只用于定义类型 - Use interfaces only to define types

当类实现接口时，接口就充当可以引用这个类的实例的**类型（type）**。因此，类实现了接口，就表明客户端可以对这个类的实例实施某些动作。为了任何其他目的而定义接口是不恰当的。

有一种接口称为**常量接口（constant interface）**，它不满足上面的条件。这种接口不包含任何方法，它只包含**静态的final域**，每个域都导出一个常量。使用这些常量的类实现这个接口，以避免用类名来修饰常量名。

**常量接口模式是对接口的不良使用**。类在内部使用某些常量，这纯粹是实现细节。实现常量接口会导致把这样的实现细节泄露到该类的导出API中。

如果要导出常量，可以有几种合理的选择方案：

- 如果这些常量与某个现有的类或者接口紧密相关，就应该把这些常量添加到这个类或者接口中；
- 如果这些常量最好被看作枚举类型的成员，就应用使用**枚举类型（enum type）** 来导出这些常量。否则，就应该使用**不可实例化的工具类（utility class）** 来导出这些常量。

总而言之，接口应该只被用来定义类型，它们不应该被用来导出常量。

### 4.9 类层次优于标签类 - Prefer class hierarchies to tagged classes

有时可能会遇到带有两种甚至更多风格的实例的类，并包含表示实例风格的**标签（tag）域**。这种**标签类（tagged class）** 有许多缺点。

- 它们中充斥着样版代码，包括枚举声明、标签域以及条件语句；
- 由于多个实现乱七八糟地挤在单个类中，破坏了可读性；
- 由于实例承担着属于其他风格的不相关的域，因此内存占用也增加了；
- 域不能做成 final 的，除非构造器初始化了不相关的域，产生了更多的样版代码；
- 无法给标签类添加新的风格，除非可以修改它的源文件。

一句话，标签类过于冗长、容易出错，并且效率低下。

幸运的是，Java提供了其他更好的方法来定义能表示多种风格对象的单个数据类型：子类型化（subtyping）。**标签类正是对类层次的一种简单效仿**。

将标签类转变成类层次步骤：
- 首先要为标签类中的每个方法都定义一个包含抽象方法的抽象类，标签类的行为依赖于标签值；
- 如果还有其他的方法行为不依赖于标签的值，就把这样的方法放在这个抽象类中；
- 同样地，如果所有的方法都用到了某些数据域，就应该把它们放在这个抽象类中；
- 接下来，为每种标签类都定义这个抽象类的具体子类。

类层次纠正了前面提到过的标签类的所有缺点。同时，它们可以用来反映类型之间本质上的层次关系，有助于增强灵活性，并有助于更好地进行编译时类型检查。

### 4.10 静态成员优于非静态成员 - Favor static member classes over nonstatic

**嵌套类（nested class）** 是指定义在另一个类的内部的类。嵌套类存在的目的应该只是为了它的**外围类（enclosing class）** 提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该是**顶层类（top-level class）**。

嵌套类有四种：**静态成员类（static member class）**、**非静态成员类（nonstatic member class）**、**匿名类（anonymous class）** 和 **局部类（local class）**。除了静态成员类，其他三种都成为**内部类（inner class）**。

**静态成员类**是普通的类，只是碰巧被声明在另一个类的内部而已，它可以**访问外围类的所有成员，包括那些声明为私有的成员**。静态成员类是外围类的一个静态成员，与其他的静态成员一样，也遵守同样的可访问性规则。如果它被声明为私有的，它就只能在外围类的内部才可以被访问，等等。

**静态成员类**的一种常见用法是**作为公有的辅助类**，只有与它的外部类一起使用才有意义。

**私有静态成员类**的一种常见用法是代表外围类所代表的对象的组件。

与**静态成员类**类相比，**非静态成员类**的每个实例都隐含地与外围类的一个**外围实例（enclosing instance）** 相关联。在**非静态成员类**的实例方法内部，可以调用外围实例的方法，或是使用修饰过的**this(qulified this)** 构造获得外围实例的引用。如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是**静态成员类**：在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。

当非静态成员类的实例被创建的时候，**它和外围实例之间的关联关系也随之被建立起来**；而且，这种关联关系以后不能被修改。通常情况下，当外围类的某个实例方法的内部调用非静态成员类的构造器时，这种关联关系被自动建立起来。使用表达式**enclosingInstance.new MemberClass(args)** 类手动建立这种关联关系也是有可能的，但是很少使用。**这种关联关系需要消耗非静态成员类实例的空间，并且增加构造的时间开销**。

非静态成员类的一种常见用法是**定义一个 Adapter**，它允许外部类的实例被看作是另一个不相关的类的实例。

非静态成员类的每个实例都将包含一个额外的指向外围对象的引用，保持这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收时仍然得以保留。由此造成的内存泄露可能是灾难性的。但是常常难以发现，因为这样引用是不可见的。

匿名类是没有名字的，它不是外围类的一个成员。它并不与其他的成员一起被声明，而是在使用的同时被声明和实例化。匿名类可以出现在代码中任何允许存在表达式的地方。当且仅当匿名类出现在非静态的环境中时，它采用外围实例。但是即使它们出现在静态的环境中，也不可能拥有任何静态成员，而是拥有**常数常量（constant variable）** ，常数常量是 final 基本类型，或者被初始化成常量表达式的字符串域。

局部类是四种嵌套类中使用最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。

## 第5章 泛型

## 第6章 枚举和注解

## 第7章 Lambda和Stream

## 第8章 方法

## 第9章 通用编程

## 第10章 异常

## 第11章 并发

## 第12章 序列化
