# jvm经典垃圾收集器

在谈论垃圾收集器的上下文语境中，“并行”和“并发”的理解：

- 并行（Parallel）：并行描述的是多条垃圾收集线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。
- 并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

## 新生代收集器

### Serial 收集器

Serial 收集器是采用**标记-复制**算法的**单线程工作**的新生代收集器。但它的“单线程”的意义并不仅仅是说明它会使用一个处理器或一条收集线程去完成收集工作，更重要的是强调在它进行垃圾收集时，必须**暂停其他所有的工作线程（Stop The World）**，直到它收集结束。

迄今为止， Serial 收集器依然是 HotSpot 虚拟机运行在**客户端模式**（64位的HotSpot虚拟机不支持客户端模式）下的默认新生代收集器，有着优于其他收集器的地方：

- 简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；
- 对于单核处理器或处理器核心数较少的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然就可以获得最高的单线程收集效率。

使用参数 `-XX:+UseSerialGC` 开启 Serial 收集器 和 Serial Old 收集器组合。

### ParNew 收集器

ParNew 收集器是采用**标记-复制**算法的**多线程并行工作**的新生代收集器，实质上是 Serial 收集器的多线程并行版本。它使用多条线程进行垃圾收集，同样会暂停所有用户线程（Stop The World）。

ParNew 收集器是运行在**服务端模式**下的 HotSpot 虚拟机，尤其是 JDK 7 之前的遗留系统中的首选新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：除了 Serial 收集器外（JDK 9 已取消Serial + CMS 配合），目前只有它能与 CMS 收集器配合工作。

使用参数 `-XX:+UseParNewGC` 开启 ParNew 收集器。

ParNew 收集器是激活 CMS后（使用 `-XX:+UseConcMarkSweepGC` 选项）的默认新生代收集器，也可以使用 `-XX: +/-UseParNewGC` 选项（JDK 9 开始，此选项被取消）来强制指定或者禁用它。

ParNew 收集器默认开启的收集线程数与处理器核心数量相同，可以使用 `-XX:ParallelGCThreads` 参数来限制垃圾收集的线程数。

### Parallel Scavenge 收集器

Parallel Scavenge 收集器同样是采用**标记-复制**算法的**多线程并行工作**的新生代收集器。它的关注点与其他垃圾收集器不同，CMS 等垃圾收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge 收集器的目标是**达到一个可控制的吞吐量（Throughput）**。所谓的吞吐量就是处理器用于用户代码的时间与处理器总消耗时间的比值：

```
    吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 运行垃圾收集时间）
```

停顿时间越短（CMS等收集器）就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量（Parallel Scavenge 收集器，单次的垃圾收集时间可能较长，总的垃圾收集时间较短）则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合**在后台运算而不需要太多交互的分析任务**。

使用参数 `-XX:+UseParallelGC` 开启 Parallel Scavenge 收集器和 Parallel Old 收集器组合，JDK 1.7 （包括）之后默认采用Parallel Scavenge 收集器作为新生代收集器。不能和 CMS 收集器配合使用。

Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大收集停顿时间的 `-XX:MaxGCPauseMillis` 参数以及直接设置吞吐量大小的 `-XX:GCTimeRatio` 参数。

`-XX:MaxGCPauseMillis` 参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变得更快，**垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的**：系统把新生代调得小一些，收集 300MB 新生代肯定比收集 500M B快，但这也直接导致垃圾收集发生得**更频繁**，原来 10 秒收集一次、每次停顿 100 毫秒，现在变成 5 秒收集一次、每次停顿 70 毫秒。停顿时间的确在下降，但吞吐量也降下来了。

`-XX:GCTimeRatio` 参数的值则应当是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于**吞吐量的倒数**。譬如把此参数设置为 19 ，那允许的最大垃圾收集时间就占总时间的 5%（即1/(1+19)），默认值为 99，即允许最大 1%（即1/(1+99)）的垃圾收集时间。

Parallel Scavenge 收集器的**自适应调节策略**是区别于 ParNew 收集器的一个重要特性。参数 `-XX:+UseAdaptiveSizePolicy` 是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden 与 Survior 区的比例（-XX: SurvivorRatio）、晋升老年代对象大小（-XX: PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个不错的选择。只需要把基本的内存数据设置好（如 -Xmx 设置最大堆），然后使用 `-XXMaxGCPauseMillis` 参数（更关注最大停顿时间）或 `-XX:GCTimeRatio` 参数（更关注吞吐量）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。



## 老年代收集器

### Serial Old 收集器

Serial Old 收集器是基于**标记-整理**算法的**单线程工作**的老年代收集器。它的主要意义也是供**客户端模式**（64位的HotSpot虚拟机不支持客户端模式）下的 HotSpot 虚拟机使用。如果在**服务到模式**下，它也可能有两种用途：一种是在 JDK 5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用，另外一种就是作为 CMS 收集器发生失败时的后备预案，在并发收集发生 `Concurrent Mode Failure` 时使用。

使用参数 `-XX:+UseSerialGC` 开启 Serial 收集器 和 Serial Old 收集器组合。

### Parallel Old 收集器

Parallel Old 收集器是基于**标记-整理**算法的**多线程并行工作**的老年代收集器，是 Parallel Scavenge 收集器的老年代版本。这个收集器是直到 JDK 6 时才开始提供的，在此之前，新生代的 Parallel Scavenge 收集器一直处于相当尴尬的状态，原因是如果新生代选择了 Parallel Scavenge 收集器，老年代除了 Serial Old（PS MarkSweep） 收集器以外别无选择，其他表现良好的老年代收集器，如 CMS 无法与它配合工作。

直到 Parallel Old 收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在**注重吞吐量或者处理器资源较为稀缺**的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。

使用参数 `-XX:+UseParallelGC` 开启 Parallel Scavenge 收集器和 Parallel Old 收集器组合，JDK 1.7 （包括）之后默认采用Parallel Scavenge 收集器作为新生代收集器。不能和 CMS 收集器配合使用。

### CMS 收集器

CMS（Concurrent Mark Sweep） 收集器是基于**标记-清除**算法的老年代收集器。它的运作过程相对于前面几种收集器来说要复杂一些，整个过程分为四个步骤，包括：

- 初始标记（CMS initial mark）：会“Stop The World”。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；
- 并发标记（CMS concurrent mark）：垃圾收集线程和用户线程同时工作。并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起**并发**运行；
- 重新标记（CMS remark）：会“Stop The World”。重新标记阶段则是为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录（采用**增量更新**的方式），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；
- 并发清除（CMS concurrent sweep）：并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于**不需要移动存活对象**，所以这个阶段也是可以与用户线程同时并发的。

由于在整个过程中**耗时最长的并发标记和并发清除阶段**中，垃圾收集线程都可以与用户线程一起工作，所以从总体上来说，CMS 收集器的**内存回收过程是与用户线程一起并发执行的**。

CMS 收集器优点：并发收集，低停顿。

CMS 收集器缺点：

- CMS 收集器对处理器资源非常敏感。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS 默认启动的回收线程数是 `（处理器核心数量 + 3） / 4`，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用**不超过 25%** 的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器资源不足四个时（1核：100%，2核：50%，3核：33.33%，4核：25%），CMS 对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。
- 由于 CMS 收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的 Full GC 的产生。在 CMS 的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，**CMS 无法在当次收集中处理掉它们**，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就**还需要预留足够内存空间**提供给用户线程使用，因此 CMS 收集器 不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在 JDK 5 的默认设置下，CMS 收集器当老年代使用了 **68%** 的空间后就会被激活，这是一个偏保守的设置，如果在实际使用中老年代增长并不是太快，可以适当调高参数 `-XX:CMSInitiatingOccupancyFraction` 的值来提高 CMS 的触发百分比，降低内存回收频率，获取更好的性能。到了 JDK 6 时，CMS 收集器的启动阈值就已经默认提升至 **92%**。但这也会更容易面临另一种风险：要是 CMS 运行期间预留的内存无法满足程序分配新对象的需求，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程运行，临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，但这样停顿的时间就很长了。所以参数 `-XX:CMSInitiatingOccupancyFraction` 设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。
- CMS 是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量的空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 `Full GC` 的情况。为了解决整个问题，CMS 收集器提供了一个 `-XX:+UseCMSCompactAtFullCollection` 开关参数（默认是开启的，此参数从 JDK 9 开始废弃），用于在 CMS 收集器不得不进行 `Full GC` 时开启内存碎片的合并整理过程，由于整个内存整理必须移动存活的对象，（在 Shenandoah 和 ZGC 出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者还提供了另外一个参数 `-XX:CMSFullGCsBeforeCompaction` （此参数从 JDK 9 开始废弃），这个参数的作用是要求 CMS 收集器在执行过若干次（数值由参数决定）不整理空间的 `Full GC` 之后，下一次进入 `Full GC` 前会先进行碎片整理（默认值为 0， 表示每次进入 Full GC 时都进行碎片整理）。

使用参数 `-XX:+UseConcMarkSweepGC` （默认会增加 `-XX:+UseParNewGC` 参数）开启 ParNew 收集器和 CMS 收集器组合。

所有收集器中只有 CMS 有针对老年代的 Old GC。其他老年代收集器是否都是 Full GC？

## 混合收集器

### Garbage First 收集器

Garbage First（简称 G1）收集器开创了收集器**面向局部收集的设计思路和基于 Region 的内存布局形式**。被 Oracle 官方称为“全功能的垃圾收集器”（Fully-Featured Garbage Collector）。

G1 是一款主要面向服务端应用的垃圾收集器。JDK 9 开始，G1 取代 **Parallel Scavenge 加 Parellel Old 组合**，成为服务端模式下默认垃圾收集器，而 CMS 则沦落至被声明为不推荐使用（Deprecate）的收集器。 

G1 的目标是建立起“停顿时间模型”（Pause Prediction Model），停顿时间模型的意思是能够支持指定在一个长度为 **M** 的时间片段内，消耗在垃圾收集上的时间大概率不超过 **N** 毫秒这样的目标。

G1 收集器之前的所有其他收集器，包括 CMS 在内，垃圾收集的目标范围要么是**整个新手代（Minor GC）**，要么就是**整个老年代（Major GC）**，再要么就是**整个 Java 堆（Full GC）**。而 G1 可以面向**堆内存任何部分来组成回收集（Collection Set，一般简称 CSet）** 进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 **Mixed GC 模式**。

G1 开创的**基于 Region 的内存布局**是它能够实现整个目标的关键。G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为**多个大小相等的独立区域（Region）**，每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survior 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能够获取很好的收集效果。

Region 中还有一类**特殊的 Humongous 区域**，专门用来存储大对象。G1 认为只要大小超过了**一个 Region 容量一半的对象**即可判断为大对象。每个 Region 的大小可以通过参数 `-XX:G1HeapRegionSize` 设置，取值范围为 1MB~32MB，且应为 2 的 N 次幂。而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 Humongous Region 之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。

G1 收集器之所以能建立可预测的停顿时间模型，是因为它**将 Region 作为单次回收的最小单元**，即每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。更具体的思路是让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的“价值”大小，价值即**回收所获得的空间大小以及回收所需时间的经验值**，然后在后台维护一个**优先级列表**，每次根据用户设定允许的收集停顿时间（使用参数 `-XX:MaxGCPauseMillis` 指定，默认值是 200 毫秒），优先处理回收价值收益最大的那些 Region，这也就是 “Garbage First” 名字的由来。这种使用 Region 划分内存空间，以及具有优先级的区域回收方式，保证了 G1 收集器在有限的时间内获取尽可能高的收集效率。

将 Java 堆分成多个独立 Region 后，对于跨 Region 的引用，每个 Region 都维护有自己的记忆集，这些记忆集会记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。由于 Region 数量比传统收集器的分代数量明显要多得多，因此 G1 收集器要比其他的传统垃圾收集器**有着更高的内存占用负担**。根据经验，G1 至少要耗费大约相当于 Java 堆容量 10% 至 20% 的额外内存来维持收集器工作。

G1 收集器的运作过程大致可划分为以下四个步骤：

- 初始标记（Inital Marking）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Top at Mark Start）指针的值，让下一个阶段（并发标记阶段）用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要**停顿用户线程**，但耗时很短，而且是借助进行 Minor GC 的时候同步完成的，所有 G1 收集器在这个阶段实际并没有额外的停顿。
- 并发标记（Concurrent Marking）：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可与**用户程序并发执行**。当对象图扫描完成以后，还有重新处理 SATB （原始快照）记录下的并发时有引用变动的对象。
- 最终标记（Final Marking）：**对用户线程做一个短暂的停顿**，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB（原始快照） 记录。
- 筛选回收（Live Data Counting and Evacuation）：负责更新 Region 的统计数据，对各个 Region 的回收机制和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须**暂停用户线程**，由多个收集器线程并行完成的。

G1 收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是**在延迟可控的情况下获得尽可能高的吞吐量**，所有才能担当起“全功能收集器”的重任与期望。

G1 收集器和 CMS 收集器比较：

- CMS 收集器采用“标记-清除”算法，产生大量的内存空间碎片；G1 收集器从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个 Region 之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。
- 在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 高。

目前在小内存应用上 CMS 的表现大概率仍然要会优于 G1，而在大内存应用上 G1 则大多能发挥其优势，这个优劣势的 Java 堆容量平衡点通常在 **6GB 至 8GB** 之间。

## JVM 实践

### 常用垃圾回收器组合参数设定

- `-XX:+UseSerialGC`: Serial New(DefNew) + SerialOld .
- `-XX:+UseConcMarkSweepGC`: ParNew + CMS + SerialOld（后备预案）
- `-XX:+UseParallelGC`（默认）: Parallel Scavenge + Parallel Old(1.7 & 1.8默认)
- `-XX:+UseParallelOldGC`: Parallel Scavenge + Pallel Old（该参数在JDK1.5之后已无用）
- `-XX:+UseG1GC`: G1

### 查看JVM默认垃圾回收器方法

使用以下命令查看：

```
    jcmd <pid> VM.flags
```

输出内容如下：

```
<pid>:
-XX:CICompilerCount=4 -XX:InitialHeapSize=1073741824 -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=357564416 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=357564416 -XX:OldSize=716177408 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC
```

### 查看某个flag的值

使用如下命令查看：

```
    jcmd <pid> VM.flags -all | grep CMSInitiatingOccupancyFraction
```

## 参考

- [Java HotSpot VM Options](https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html)
- [Java Platform, Standard Edition Tools Reference](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html)
- [JVM的server模式和client模式](https://blog.csdn.net/qq_26545305/article/details/70241939)
- [JVM调优实战一（Parallel + ParallelOld）](https://blog.csdn.net/bch1991/article/details/109458333)

