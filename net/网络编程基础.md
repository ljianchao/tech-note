# 网络编程基础

## I/O基础入门

Linux的内核将所有的外部设备都看做一个文件来操作，对一个文件的读写操作都会调用内核提供的系统命令，返回一个`file descriptor`（fd，文件描述符）。而对一个socket的读写也会有相应的描述符，称为`socketfd`（socket描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径、数据区等一些属性）。

Unix系统`I/O`模型最为显著的特性之一就是其`I/O`通用型概念。也就是说，同一套系统调用（`open()`, `read()`, `write()`,` close()`等）所执行的`I/O`操作，可施之于所有文件类型，包括设备文件在内。（应用程序发起的`I/O`请求，内核会将其转化为相应的文件系统操作，或者设备驱动程序操作，以此来执行针对目标文件或设备的`I/O`操作。）因此，采用这些系统调用的程序能够处理任何类型的文件。

就本质而言，内核只提供一种文件类型：**字节流序列**，在处理磁盘文件、磁盘或磁带设备时，可通过`lseek()`系统调用来随机访问。


### I/O 请求

I/O 请求可用分为两个阶段，分别为**调用阶段**和**执行阶段**。

- 第一个阶段为**I/O 调用阶段**，即用户进程向内核发起系统调用。
- 第二个阶段为**I/O 执行阶段**。此时，内核等待 I/O 请求处理完成返回。该阶段分为两个过程：首先**等待数据就绪**，并写入内核缓冲区；随后将内核缓冲区数据拷贝至用户态缓冲区。

### I/O 模式

Linux 包含5种 I/O 模式：

- 阻塞 I/O（BIO，Blocking IO）：应用进程向内核发起 I/O 请求，发起调用的线程一直等待内核返回结果。一次完整的 I/O 请求称为 BIO（Blocking IO，阻塞 I/O），所以 BIO 在实现异步操作时，只能使用**多线程模型**，一个请求对应一个线程。但是，线程的资源是有限且宝贵的，创建过多的线程会增加线程切换的开销。
- 非阻塞 I/O（NIO，Non-blocking IO）：应用进程向内核发起 I/O 请求后不再会同步等待结果，而是立即返回，通过**轮询**的方式获取请求结果。NIO 相比 BIO 虽然大幅提升了性能，但是轮询过程中大量的系统调用导致上下文切换开销很大。所以，单独使用非阻塞 I/O 时效率并不高，而且随着并发量的提升，非阻塞 I/O 会存在严重的性能浪费。
- I/O 多路复用（IO multiplexing）：多路复用实现了**一个线程处理多个 I/O 句柄的操作**。多路指的是多个数据通道，复用指的是使用一个或者多个固定线程来处理每一个 Socket。`select`、`poll`、`epoll` 都是 I/O 多路复用的具体实现，**线程一次 select 调用可用获取内核态中多个数据通道的数据状态**。多路复用解决了同步阻塞 I/O 和同步非阻塞 I/O 的问题，是一种高效的 I/O 模型。
- 信号驱动 I/O（Signal driven IO）：信号驱动 I/O 并不常用，它是一种**半异步**的 I/O 模型。在使用信号驱动 I/O 时，当数据准备就绪后，内核通过发送一个 **SIGIO** 信号通知应用进程，应用进程就可用开始读取数据了。
- 异步 I/O（Asynchronous IO）：异步 I/O 最重要的一点是从内核缓冲区拷贝数据到用户态缓冲区的过程也是由系统异步完成，应用进程只需要在指定的数组中引用数据即可。异步 I/O 与信号驱动 I/O 这种半异步模式的主要区别：信号驱动 I/O 由内核通知用户进程何时可以开始一个 I/O 操作（从内核缓冲区拷贝数据到用户态缓冲区），而异步 I/O 由内核通知 I/O 操作（从内核缓冲区拷贝数据到用户态缓冲区）何时已经完成。

# 参考

- [IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）](https://blog.csdn.net/historyasamirror/article/details/5778378)
