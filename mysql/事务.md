# 事务(Transactions)

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。

一个运行良好的事务处理系统，必须具备这些标准特征：`原子性（Atomicity）`、`一致性（Consistency）`、`隔离性（Isolation）`和`持久性（Durability）`，简写为`ACID`。

- 原子性（Atomicity）

    一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

- 一致性（Consistency）

    数据库总是从一个一致性的状态转换到另一个一致性的状态。

- 隔离性（Isolation）

    通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在讨论隔离级别（Isolation level）的时候，会发现为什么我们要说"通常来说"是不可见的。

- 持久性（Durability）

    一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即时系统崩溃，修改的数据也不会丢失。持久性是个有点儿模糊的概念，因为实际上持久性也分很多不同的级别。

一个实现了ACID的数据库，会增加系统的开销，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。用户可以根据业务是否需要事务处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。

## 隔离级别（Isolation Levels）

隔离性其实比想像的要复杂。在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

- READ UNCOMMITED(读未提交)
  
    在`READ UNCOMMITED`级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为`脏读（Dirty Read）`。

- READ COMMITED（读已提交）

    大多数数据库系统的默认隔离级别都是`READ COMMITED`（但MySQL不是）。一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见。这个级别有时候也叫做`不可重复读（nonrepeatable read）`，因为（在同一事务中）两次执行同样的查询，可能会得到不一样的结果。

- REPEATABLE READ（可重复读）

    该级别保证了在同一事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个`幻读（Phantom Read）`的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，产生了`幻行（Phantom Row）`。InnoDB和XtraDB存储引擎通过`多版本并发控制（MVVC，Multiversion Concurrency Control）`解决了幻读的问题。

    可重复读是MySQL的默认事务隔离级别。Oracle数据库的默认隔离级别是读已提交，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要记得将MySQL的隔离级别设置为读已提交。

- SERIALIZABLE（可串行化）

    SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

## 事务隔离的实现

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。

### 长事务

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开.

查找持续时间超过60s的长事务：

```
    select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
```

## 事务日志（Transaction Logging）

事务日志可以帮助提高事务的效率。// TODO


## MySQL中的事务

MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

### 事务的启动方式

MySQL的事务启动方式有以下几种：

- 显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback（必须显示执行，autocommit功能不生效）。

- `set autocommit=0`（默认为1），这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断连接。

### 自动提交（AUTOCOMMIT）

MySQL默认采用自动提交（AUTOCOMMIT）模式。如果不显示地开启一个事务，每个查询都被当做一个事务执行提交操作。

### 多版本并发控制（Multiversion Concurrency Control）

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了`多版本并发控制（MVCC）`。

可以认为MVCC是行级锁的变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作（nonblocking reads），写操作也只锁定必要的行。

MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的（解决了幻读问题）。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能时不一样的。

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。当然存储的并不是实际的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会递增（是否是整个数据库共享一个系统版本号？）。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到每行记录的版本号进行比较。下面看一下在`REPEATABLE READ`隔离级别下，MVCC具体是如何操作的。

- SELECT

    InnoDB会根据以下两个条件检查每行记录：
        
        a. InnoDB只查找版本早于当前事务版本的数据行（行的版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的（小于），要么是事务自身插入或者修改过（等于）。
        
        b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

    只有符合上述两个条件的记录，才能返回作为查询结果。

- INSERT

    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

- DELETE

    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

- UPDATE

    InnoDB拷贝当前的行数据，创建新的行，并保存当前系统版本号作为新行的行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。

MVCC只在`REPEATABLE READ`和`READ COMMITED`两个隔离级别下工作。

# spring事务管理