# 事务(Transactions)

事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。

一个运行良好的事务处理系统，必须具备这些标准特征：`原子性（Atomicity）`、`一致性（Consistency）`、`隔离性（Isolation）`和`持久性（Durability）`，简写为`ACID`。

- 原子性（Atomicity）

    一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

- 一致性（Consistency）

    数据库总是从一个一致性的状态转换到另一个一致性的状态。

- 隔离性（Isolation）

    通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在讨论隔离级别（Isolation level）的时候，会发现为什么我们要说"通常来说"是不可见的。

- 持久性（Durability）

    一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即时系统崩溃，修改的数据也不会丢失。持久性是个有点儿模糊的概念，因为实际上持久性也分很多不同的级别。

一个实现了ACID的数据库，会增加系统的开销，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。用户可以根据业务是否需要事务处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择一个非事务型的存储引擎，可以获得更高的性能。

## 隔离级别（Isolation Levels）

隔离性其实比想像的要复杂。在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

- READ UNCOMMITED(读未提交)
  
    在`READ UNCOMMITED`级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为`脏读（Dirty Read）`。

- READ COMMITED（读已提交）

    大多数数据库系统的默认隔离级别都是`READ COMMITED`（但MySQL不是）。一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见。这个级别有时候也叫做`不可重复读（nonrepeatable read）`，因为（在同一事务中）两次执行同样的查询，可能会得到不一样的结果。

- REPEATABLE READ（可重复读）

    该级别保证了在同一事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个`幻读（Phantom Read）`的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，产生了`幻行（Phantom Row）`。InnoDB和XtraDB存储引擎通过`多版本并发控制（MVCC，Multiversion Concurrency Control）`解决了幻读的问题。

    可重复读是MySQL的默认事务隔离级别。Oracle数据库的默认隔离级别是读已提交，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，一定要记得将MySQL的隔离级别设置为读已提交。

- SERIALIZABLE（可串行化）

    SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

## 事务隔离的实现

在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。

### 长事务

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有20GB，而回滚段有200GB的库。最终只好为了清理回滚段，重建整个库。

除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开.

查找持续时间超过60s的长事务：

```
    select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
```

## 事务日志（Transaction Logging）

事务日志可以帮助提高事务的效率。// TODO


## MySQL中的事务

MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

### 事务的启动方式

MySQL的事务启动方式有以下几种：

- 显式启动事务语句， `begin`或`start transaction`。配套的提交语句是`commit`，回滚语句是`rollback`（必须显示执行，`autocommit`功能不生效）。在可重复读隔离级别下，`begin|start transaction`并不是一个事务的起点，在执行他们之后的第一个操作InnoDB表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用`start transaction with consistent snapshot`命令。（事务启动的标识是否是分配事务id？）

- `set autocommit=0`（默认为1），这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断连接。

### 自动提交（AUTOCOMMIT）

MySQL默认采用自动提交（AUTOCOMMIT）模式。如果不显示地开启一个事务，每个查询都被当做一个事务执行提交操作。

### 多版本并发控制（Multiversion Concurrency Control）

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了`多版本并发控制（MVCC）`。

可以认为MVCC是行级锁的变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作（nonblocking reads），写操作也只锁定必要的行。

MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的（解决了幻读问题）。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能时不一样的。

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间（或删除时间）。当然存储的并不是实际的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会递增（是否是整个数据库共享一个系统版本号？）。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到每行记录的版本号进行比较。下面看一下在`REPEATABLE READ`隔离级别下，MVCC具体是如何操作的。

InnoDB里面每个事务都有一个唯一的事务ID，叫作`transaction id`。它是事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格**递增**的。

- SELECT

    InnoDB会根据以下两个条件检查每行记录：
        
        a. InnoDB只查找版本早于当前事务版本的数据行（行的版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的（小于），要么是事务自身插入或者修改过（等于）。
        
        b. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。

    只有符合上述两个条件的记录，才能返回作为查询结果。

- INSERT

    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。

- DELETE

    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。

- UPDATE

    InnoDB拷贝当前的行数据，创建新的行，并保存当前系统版本号作为新行的行版本号，同时保存当前系统版本号到原来的行作为行删除标识。每次事务更新数据的时候，都会生成一个新的数据版本，并且把`transaction id`赋值给这个数据版本的事务ID，记为`row trx_id`。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。

MVCC只在`REPEATABLE READ`和`READ COMMITED`两个隔离级别下工作。

## 事务和锁

### 一致性读

InnoDB在实现MVCC时用到了一致性读视图（consistent read view），用于支持RC（Read Committed）和RR（Repeatable Read）隔离级别的实现。它没有真实的物理结构，语句更新时会生成`undo log`（回滚日志），每次需要的时候根据当前版本和`undo log`计算出来。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

- 版本未提交，不可见

- 版本已提交，但是是在视图创建后提交的，不可见

- 版本已提交，而且是在视图创建前提交的，可见。

### 当前读

**当前读**（current read）：更新数据操作都是先读后写的，而这个读，只能读当前的值（当前数据版本的值）。

除了`update`语句外，`select`语句如果加锁，也是当前读

- select加读锁（S锁、共享锁）
```
    select k from t where id=1 lock in share mode;
```
- select加写锁（X锁，排他锁）
```    
    select k from t where id=1 for update;
```

一致性读、当前读和行锁：可重复读的核心就是一致性读（consistent read），而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

读提交的逻辑和可重复读的逻辑类似，最主要的区别：

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图，即查询只承认在事务启动前就已经提交完成的数据。

- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图，即查询只承认在语句启动前就已经提交完成的数据。


# spring事务管理
